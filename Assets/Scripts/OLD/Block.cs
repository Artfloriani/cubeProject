using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class Block : MonoBehaviour {

	//Size of the blocks Generated by this script
	public float cubeSize = 0.5f;

	//Size of the whole block
	public float blockSize = 3.0f;

	//Radius Multipliier
	public float radiusMult = 3;

	//Seed for generating the random terrain
	public double seed = 1;

	//Base block prefab
	public GameObject block;

	//Public for debug
	public float _distFrPlayer = 0;

	//This is only true for the most topLevel Block
	public bool isPlanet = false;

	//Used to generate new terrains
	private double lastSeed;


	//Dictionary containing all blocks
	private Dictionary<Vector3, GameObject> cubePositions;
	

	//If terrain was already generated
	private bool generated = false;

	//PI value for circle
	private float PI = 3.14159265f;

	public bool displayingCubes = false;

	private GameObject boudingCube;


	
	void Start()
	{
		//Dictionary that keeps all the blocks. I used a dictionary so that I can avoid spawning two blocks on the same place without checking
		//the whole array
		cubePositions = new Dictionary<Vector3, GameObject>();


		seed = Random.Range(10.0f, 20.0f);

		lastSeed = seed;


		generated = false;

		_distFrPlayer = Vector3.Distance (this.transform.position, GameObject.Find ("Player").transform.position);

		float distanceFromSeed = Vector3.Distance (this.transform.position, GameObject.Find ("PlanetSeed").transform.position);

		GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
		cube.GetComponent<BoxCollider> ().enabled = false;
		cube.GetComponent<Renderer> ().material.color = new Color (Mathf.Abs((blockSize - distanceFromSeed)/22.0f), Mathf.Abs((blockSize - distanceFromSeed)/22.0f), Mathf.Abs((blockSize - distanceFromSeed)/22.0f));
		cube.transform.position = this.transform.position;
		cube.transform.localScale = new Vector3(blockSize, blockSize, blockSize);
		cube.SetActive (false);
		//cube.transform.SetParent (this.transform);


		boudingCube = cube;


		if (_distFrPlayer > blockSize*4.0f) {
			displayingCubes = true;
		}


	}
	
	// Update is called once per frame
	void Update()
	{

		//if (this.GetComponent<UpdateCheckScript> ().getUpdateBlocks ()) {
		if (blockSize > 0.01f) {
			_distFrPlayer = Vector3.Distance (this.transform.position, GameObject.Find ("Player").transform.position);
			if (_distFrPlayer > blockSize * 4.0f) {
				if (displayingCubes) {


					foreach (KeyValuePair<Vector3, GameObject> entry in cubePositions) {
						entry.Value.SetActive (false);
						entry.Value.GetComponent<Block> ().boudingCube.SetActive (false);
					}
					boudingCube.SetActive (true);
					displayingCubes = false;
				}
			} else {
				if (!displayingCubes) {
					if (!generated) {
						generateTerrain ();
						generated = true;
					}
					foreach (KeyValuePair<Vector3, GameObject> entry in cubePositions) {
						entry.Value.SetActive (true);
						if (entry.Value.GetComponent<Block> ().boudingCube != null)
							entry.Value.GetComponent<Block> ().boudingCube.SetActive (true);
					}
					boudingCube.SetActive (false);
					displayingCubes = true;
				}
			}
		}
		//}



		
	}
	
	void generateTerrain()
	{

		if (blockSize > 0.005f) {
			if (isPlanet) {
				for (float i = 0; i < 360; i += 1.0f) {
					for (float j = 0; j < 180; j += 1.0f) {
						float radius = radiusMult - (radiusMult / 3.0f) * Mathf.PerlinNoise ((float)seed * (i / 360.0f), (float)seed * (j / 180.0f));
						//Use the equation of the Spherical Coordinate system to display a sphere
						Vector3 posVec = new Vector3 ((float)radius * Mathf.Sin ((i) * PI / 180.0f) * Mathf.Cos ((j) * PI / 180.0f), radius * Mathf.Sin ((i) * PI / 180.0f) * Mathf.Sin ((j) * PI / 180.0f), radius * Mathf.Cos ((i) * PI / 180.0f));
									


						addCube (posVec);

					}
				}
			} else {
				Vector3 planetPos = GameObject.Find ("PlanetSeed").transform.position;
				int angle = (int)Vector3.Angle (this.transform.position, planetPos);
				for (int i = angle; i < 180 + angle; i += 1) {
					for (int j = 0; j < 90; j += 1) {
						float radius = blockSize - (blockSize / 3.0f) * Mathf.PerlinNoise ((float)seed * (i / 180.0f), (float)seed * (j / 90.0f));
						//Use the equation of the Spherical Coordinate system to display a sphere
						Vector3 posVec = new Vector3 ((float)radius * Mathf.Sin ((i) * PI / 180.0f) * Mathf.Cos ((j) * PI / 180.0f), radius * Mathf.Sin ((i) * PI / 180.0f) * Mathf.Sin ((j) * PI / 180.0f), radius * Mathf.Cos ((i) * PI / 180.0f));
					
					
						addCube (posVec);
					}
				}
			}
		
			int numberCubes = cubePositions.Count;
		}
	}
	
	
	
	void addCube(Vector3 cubePosition)
	{
		
		Vector3 diff = cubePosition;
		
		diff = new Vector3(diff.x - diff.x % cubeSize, diff.y - diff.y % cubeSize, diff.z - diff.z % cubeSize);
		
		GameObject temp;
		if (cubePositions.TryGetValue(diff, out temp))
		{

		}
		else
		{
			
			Vector3 newPos = this.transform.position + diff;
			/*GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
			cube.transform.position = newPos;
			cube.transform.localScale = new Vector3(cubeSize, cubeSize, cubeSize);*/

			GameObject cube =  (GameObject) Instantiate(block, this.transform.position + diff, Quaternion.identity);


			cube.GetComponent<Block>().cubeSize = this.cubeSize/10f;
			cube.GetComponent<Block>().blockSize = this.cubeSize;
			//cube.transform.SetParent(this.transform);
			cubePositions.Add(diff, cube);
			
		}
	}

	void removeCube(Vector3 cubePosition)
	{
		
		Vector3 diff = cubePosition;
		
		diff = new Vector3(diff.x - diff.x % cubeSize, diff.y - diff.y % cubeSize, diff.z - diff.z % cubeSize);
		
		GameObject temp;
		if (cubePositions.TryGetValue(diff, out temp))
		{
			cubePositions.Remove(diff);
		}
		else
		{

			
		}
	}
}
